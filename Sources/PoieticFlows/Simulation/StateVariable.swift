//
//  StateVariable.swift
//
//
//  Created by Stefan Urbanek on 19/09/2023.
//

import PoieticCore


/// Structure representing a reference to a simulation variable.
///
/// The structure is analogous to an entry in a symbol table generated by the
/// compiler. It provides information about where a particular simulation
/// variable can be found in the simulation state.
///
/// This structure provides information about a variable used in the simulation.
/// Variable can be built-in or computed. The computed variable is representing
/// a node in the model, typically a node with a formula.
///
public struct StateVariable: CustomStringConvertible {
    /// Index of the variable's value in a simulation state.
    ///
    public let index: Int
    
    /// Reference to a variable.
    ///
    /// The variable reference is used in arithmetic expressions and might represent
    /// a built-in variable provided by the application or a value of an object.
    ///
    /// One object can represent only one variable.
    ///
    public enum Content: Hashable, CustomStringConvertible {
        /// The variable is represented by an object with given object ID.
        ///
        case object(ObjectID)
        
        /// The variable is a built-in variable.
        ///
        case builtin(BuiltinVariable)
        
        /// Internal state of an object.
        ///
        /// An object might have additional internal states. The case parameter
        /// is ID of an object that owns the state.
        ///
        case internalState(ObjectID)
        
        /// Actual or adjusted value of the object after computation
        case adjustedResult(ObjectID)
        
        public static func ==(lhs: Content, rhs: Content) -> Bool {
            switch (lhs, rhs) {
            case let (.object(left), .object(right)): return left == right
            case let (.builtin(left), .builtin(right)): return left == right
            case let (.internalState(left), .internalState(right)): return left == right
            case let (.adjustedResult(left), .adjustedResult(right)): return left == right
            default: return false
            }
        }
        
        public var description: String {
            switch self {
            case .object(let id): "object(\(id))"
            case .builtin(let variable): "builtin(\(variable))"
            case .internalState(let id): "internalState(\(id))"
            case .adjustedResult(let id): "adjustedResult(\(id))"
            }
        }
    }
    
    /// Content of the state variable - whether it is an object or a builtin.
    ///
    public let content: Content
    
    /// Type of the simulation variable.
    ///
    /// - SeeAlso: ``StateVariable``
    ///
    public enum Kind: String {
        /// The simulation variable represents a computation defined
        /// by a node.
        case object
        /// The simulation variable represents a built-in variable.
        ///
        case builtin
        case internalState
        case adjusted
    }
    
    /// Type of the simulation variable.
    ///
    public var kind: Kind {
        switch content {
        case .builtin: .builtin
        case .object: .object
        case .internalState: .internalState
        case .adjustedResult: .adjusted
        }
    }
    
    /// Variable value type
    ///
    public let valueType: ValueType
    
    public let name: String
    
    /// ID of a simulation node that the variable represents, if the variable
    /// represents a node.
    ///
    /// ID is `nil` when the variable is a built-in variable or an internal
    /// state variable.
    ///
    /// Each object can be represented by only one state variable.
    ///
    public var objectID: ObjectID? {
        switch content {
        case .builtin(_): nil
        case .object(let id): id
        case .internalState(_): nil
        case .adjustedResult(let id): id
        }
    }
    
    public var description: String {
        "\(name)@\(index):\(kind):\(valueType)"
    }
    
    internal init(index: Int, content: StateVariable.Content, valueType: ValueType, name: String) {
        self.index = index
        self.content = content
        self.valueType = valueType
        self.name = name
    }
    
    internal init(index: Int, builtin: BuiltinVariable) {
        self.index = index
        self.content = .builtin(builtin)
        self.valueType = builtin.valueType
        self.name = builtin.name
    }

}

